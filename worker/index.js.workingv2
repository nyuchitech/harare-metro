// Enhanced Worker - Combines working API with safe asset serving
import { getAssetFromKV } from '@cloudflare/kv-asset-handler'
import { XMLParser } from 'fast-xml-parser'

// RSS feed sources for Zimbabwe news
const RSS_SOURCES = [
  {
    name: 'Herald Zimbabwe',
    url: 'https://www.herald.co.zw/feed/',
    category: 'general',
    enabled: true
  },
  {
    name: 'NewsDay Zimbabwe', 
    url: 'https://www.newsday.co.zw/feed/',
    category: 'general',
    enabled: true
  },
  {
    name: 'Chronicle Zimbabwe',
    url: 'https://www.chronicle.co.zw/feed/',
    category: 'general',
    enabled: true
  },
  {
    name: 'ZBC News',
    url: 'https://www.zbc.co.zw/feed/',
    category: 'news',
    enabled: true
  },
  {
    name: 'Business Weekly',
    url: 'https://businessweekly.co.zw/feed/',
    category: 'business',
    enabled: true
  },
  {
    name: 'Techzim',
    url: 'https://www.techzim.co.zw/feed/',
    category: 'technology',
    enabled: true
  },
  {
    name: 'The Standard',
    url: 'https://www.thestandard.co.zw/feed/',
    category: 'general',
    enabled: true
  },
  {
    name: 'ZimLive',
    url: 'https://www.zimlive.com/feed/',
    category: 'general',
    enabled: true
  }
]

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url)
    console.log('Request:', url.pathname)
    
    try {
      // Handle API routes first (highest priority)
      if (url.pathname.startsWith('/api/')) {
        console.log('Handling API request:', url.pathname)
        return await handleApiRequest(request, env, ctx)
      }

      // Try to serve static assets from KV
      try {
        return await getAssetFromKV(
          {
            request,
            waitUntil: ctx.waitUntil.bind(ctx)
          },
          {
            ASSET_NAMESPACE: env.ASSETS,
            // Serve index.html for SPA routes
            mapRequestToAsset: (req) => {
              const url = new URL(req.url)
              const pathname = url.pathname
              
              // Serve actual files for assets (js, css, images, etc.)
              if (pathname.includes('.') && !pathname.endsWith('/')) {
                return req
              }
              
              // Serve index.html for SPA routes (everything else)
              return new Request(`${url.origin}/index.html`, req)
            }
          }
        )
      } catch (assetError) {
        console.log('Asset serving failed, falling back to simple HTML:', assetError.message)
        
        // Fallback: serve a simple HTML page that loads the React app
        return new Response(`
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0" />
            <title>Harare Metro News</title>
            <style>
              body { 
                font-family: -apple-system, BlinkMacSystemFont, sans-serif;
                margin: 0;
                padding: 20px;
                background: #f3f4f6;
              }
              .container { 
                max-width: 800px; 
                margin: 0 auto; 
                background: white; 
                padding: 20px; 
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
              }
              .loading { 
                text-align: center; 
                color: #666; 
              }
              .error { 
                color: #dc2626; 
                background: #fef2f2; 
                padding: 10px; 
                border-radius: 4px;
                margin: 10px 0;
              }
              .article {
                border-bottom: 1px solid #e5e7eb;
                padding: 15px 0;
              }
              .article:last-child { border-bottom: none; }
              .article h3 { margin: 0 0 8px 0; color: #111827; }
              .article .meta { color: #6b7280; font-size: 0.875rem; margin-bottom: 8px; }
              .article .description { color: #374151; line-height: 1.5; }
              .article a { color: #2563eb; text-decoration: none; }
              .article a:hover { text-decoration: underline; }
            </style>
          </head>
          <body>
            <div class="container">
              <h1>ðŸ‡¿ðŸ‡¼ Harare Metro News</h1>
              <p class="meta">Zimbabwe News Aggregator</p>
              
              <div id="news-container">
                <div class="loading">ðŸ“° Loading latest news from Zimbabwe...</div>
              </div>
            </div>

            <script>
              async function loadNews() {
                try {
                  const response = await fetch('/api/feeds');
                  if (!response.ok) throw new Error('Failed to load news');
                  
                  const feeds = await response.json();
                  const container = document.getElementById('news-container');
                  
                  if (feeds.length === 0) {
                    container.innerHTML = '<div class="error">No news articles found.</div>';
                    return;
                  }
                  
                  container.innerHTML = feeds.slice(0, 20).map(article => \`
                    <div class="article">
                      <div class="meta">\${article.source} â€¢ \${new Date(article.pubDate).toLocaleDateString()}</div>
                      <h3><a href="\${article.link}" target="_blank" rel="noopener">\${article.title}</a></h3>
                      \${article.description ? \`<div class="description">\${article.description.substring(0, 200)}...</div>\` : ''}
                    </div>
                  \`).join('');
                  
                } catch (error) {
                  document.getElementById('news-container').innerHTML = 
                    \`<div class="error">Error loading news: \${error.message}</div>\`;
                }
              }
              
              loadNews();
              
              // Refresh every 5 minutes
              setInterval(loadNews, 5 * 60 * 1000);
            </script>
          </body>
          </html>
        `, {
          headers: { 'Content-Type': 'text/html' }
        })
      }

    } catch (error) {
      console.error('Worker error:', error)
      return new Response(`Error: ${error.message}`, { 
        status: 500,
        headers: { 'Content-Type': 'text/plain' }
      })
    }
  },

  // Scheduled task to update feeds every 6 hours
  async scheduled(event, env, ctx) {
    console.log('Running scheduled feed update...')
    ctx.waitUntil(updateFeeds(env))
  }
}

async function handleApiRequest(request, env, ctx) {
  const url = new URL(request.url)
  const path = url.pathname.replace('/api', '')

  // CORS headers
  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    'Access-Control-Max-Age': '86400',
  }

  // Handle preflight requests
  if (request.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }

  try {
    switch (path) {
      case '/health':
        return new Response(JSON.stringify({ 
          status: 'ok', 
          timestamp: new Date().toISOString(),
          sources: RSS_SOURCES.length,
          message: 'Harare Metro API is healthy!'
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        })

      case '/feeds/sources':
        return new Response(JSON.stringify(RSS_SOURCES), {
          headers: { 
            ...corsHeaders, 
            'Content-Type': 'application/json',
            'Cache-Control': 'public, max-age=3600'
          }
        })
      
      case '/feeds':
        return await getAllFeeds(env, corsHeaders)

      case '/feeds/cached':
        return await getCachedFeeds(env, corsHeaders)
      
      default:
        return new Response(JSON.stringify({ 
          error: 'Endpoint not found',
          available: ['/health', '/feeds/sources', '/feeds', '/feeds/cached']
        }), {
          status: 404,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        })
    }
  } catch (error) {
    console.error('API error:', error)
    return new Response(JSON.stringify({ 
      error: 'Internal server error',
      message: error.message 
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    })
  }
}

async function getAllFeeds(env, corsHeaders) {
  const allFeeds = []
  const parser = new XMLParser({
    ignoreAttributes: false,
    attributeNamePrefix: '@_',
    textNodeName: 'text'
  })

  const enabledSources = RSS_SOURCES.filter(source => source.enabled)
  
  // Fetch feeds with Promise.allSettled for better error handling
  const feedPromises = enabledSources.map(async (source) => {
    try {
      const controller = new AbortController()
      const timeoutId = setTimeout(() => controller.abort(), 8000) // 8s timeout
      
      const response = await fetch(source.url, {
        headers: { 
          'User-Agent': 'Harare Metro News Aggregator/1.0',
          'Accept': 'application/rss+xml, application/xml, text/xml'
        },
        signal: controller.signal
      })
      
      clearTimeout(timeoutId)
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }

      const xmlData = await response.text()
      const jsonData = parser.parse(xmlData)
      
      // Handle different RSS structures
      const channel = jsonData?.rss?.channel || jsonData?.feed
      const items = channel?.item || channel?.entry || []
      
      const processedItems = (Array.isArray(items) ? items : [items])
        .slice(0, 10)
        .map(item => ({
          title: item.title?.text || item.title || 'No title',
          description: cleanHtml(item.description?.text || item.description || item.summary?.text || item.summary || ''),
          link: item.link?.text || item.link || item.id || '#',
          pubDate: item.pubDate || item.published || item.updated || new Date().toISOString(),
          source: source.name,
          category: source.category,
          guid: item.guid?.text || item.guid || item.id || `${source.name}-${Date.now()}`
        }))
        .filter(item => item.title !== 'No title')

      return processedItems
    } catch (error) {
      console.error(`Error fetching ${source.name}:`, error.message)
      return []
    }
  })

  const results = await Promise.allSettled(feedPromises)
  
  // Combine all successful results
  results.forEach(result => {
    if (result.status === 'fulfilled') {
      allFeeds.push(...result.value)
    }
  })

  // Sort by date, most recent first
  allFeeds.sort((a, b) => new Date(b.pubDate) - new Date(a.pubDate))

  // Limit to 100 items total
  const limitedFeeds = allFeeds.slice(0, 100)

  return new Response(JSON.stringify(limitedFeeds), {
    headers: { 
      ...corsHeaders, 
      'Content-Type': 'application/json',
      'Cache-Control': 'public, max-age=900' // 15 minutes
    }
  })
}

async function getCachedFeeds(env, corsHeaders) {
  try {
    const cachedFeeds = await env.NEWS_STORAGE.get('cached_feeds')
    const lastUpdated = await env.NEWS_STORAGE.get('last_updated')
    
    if (cachedFeeds) {
      return new Response(JSON.stringify({
        feeds: JSON.parse(cachedFeeds),
        lastUpdated: lastUpdated || null,
        cached: true
      }), {
        headers: { 
          ...corsHeaders, 
          'Content-Type': 'application/json',
          'Cache-Control': 'public, max-age=300' // 5 minutes
        }
      })
    }
    
    // If no cache, fetch fresh data
    return await getAllFeeds(env, corsHeaders)
  } catch (error) {
    console.error('Cache error:', error)
    return await getAllFeeds(env, corsHeaders)
  }
}

async function updateFeeds(env) {
  try {
    console.log('Updating feed cache...')
    const response = await getAllFeeds(env, {})
    const feedsData = await response.text()
    
    await env.NEWS_STORAGE.put('cached_feeds', feedsData)
    await env.NEWS_STORAGE.put('last_updated', new Date().toISOString())
    
    console.log('Feed cache updated successfully')
  } catch (error) {
    console.error('Failed to update feed cache:', error)
  }
}

function cleanHtml(html) {
  if (typeof html !== 'string') return ''
  
  return html
    .replace(/<[^>]*>/g, '') // Remove HTML tags
    .replace(/&nbsp;/g, ' ') // Replace &nbsp; with space
    .replace(/&amp;/g, '&') // Replace &amp; with &
    .replace(/&lt;/g, '<') // Replace &lt; with <
    .replace(/&gt;/g, '>') // Replace &gt; with >
    .replace(/&quot;/g, '"') // Replace &quot; with "
    .replace(/&#39;/g, "'") // Replace &#39; with '
    .trim()
    .substring(0, 300) // Limit description length
}